package com.sb.echelon.services;

import java.lang.reflect.Field;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.Iterator;
import java.util.Map.Entry;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.ArgumentPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Service;

import com.sb.echelon.beans.AnalyzedClass;
import com.sb.echelon.beans.ColumnDefinition;
import com.sb.echelon.exceptions.IdNotSetException;
import com.sb.echelon.util.ArrayUtil;

import lombok.NonNull;

@Service
public class SaveWriter {

	@Autowired
	private JdbcTemplate jdbc;

	public <T> T save(T obj, AnalyzedClass<T> analyzed) {
		try {
			Long id = (Long) analyzed.getIdField().get(obj);

			if ((id == null || id == 0l) && analyzed.useAutoGeneration()) {
				// This auto generated object has not been previous been saved, as his ID is null.
				insertAutoGeneratedBean(obj, analyzed);
			} else if (id == null) {
				throw new IdNotSetException("The object " + obj + " does not use ID autogeneration but has no ID set.");
			} else {
				// Perform an insert or update operation.
				insertOrUpdate(obj, analyzed);
			}
			return obj;
		} catch (IllegalArgumentException | IllegalAccessException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * @param <T>
	 * @param obj
	 * @param analyzed
	 * @throws IllegalAccessException
	 */
	public <T> void insertOrUpdate(T obj, AnalyzedClass<T> analyzed) throws IllegalAccessException {
		String sql = saveStatement(analyzed, true) + onDuplicateKeyUpdateStatement(analyzed);
		
		Object[] insertArgs = makeInsertArguments(analyzed, obj, true);
		Object[] updateArgs = makeOnDuplicateArguments(analyzed, obj);
		Object[] args = ArrayUtil.concatenate(insertArgs, updateArgs, new Object[insertArgs.length + updateArgs.length]);
		
		jdbc.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql);
			var setter = new ArgumentPreparedStatementSetter(args);
			setter.setValues(ps);
			System.out.println(ps.toString());
			return ps;
		});
	}

	public <T> void insertAutoGeneratedBean(T obj, AnalyzedClass<T> analyzed) throws IllegalAccessException {
		String sql = saveStatement(analyzed);
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbc.update(connection -> {
			try {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				Object[] args = makeInsertArguments(analyzed, obj);
				var setter = new ArgumentPreparedStatementSetter(args);
				setter.setValues(ps);
				return ps;
			} catch (IllegalArgumentException | IllegalAccessException e) {
				throw new RuntimeException(e);
			}
		}, keyHolder);
		analyzed.getIdField().set(obj, keyHolder.getKey().longValue());
	}

	public <T> Object[] makeInsertArguments(AnalyzedClass<T> analyzed, T obj)
			throws IllegalArgumentException, IllegalAccessException {
		return makeInsertArguments(analyzed, obj, false);
	}

	public <T> Object[] makeInsertArguments(AnalyzedClass<T> analyzed, T obj, boolean forceIdField)
			throws IllegalArgumentException, IllegalAccessException {

		Object[] args = new Object[analyzed.useAutoGeneration() && !forceIdField
				? analyzed.getFields().size() - 1
				: analyzed.getFields().size()];

		int i = 0;
		for (Entry<Field, ColumnDefinition<?>> entry : analyzed.getFields().entrySet()) {
			if (analyzed.useAutoGeneration()
					&& entry.getValue().isPrimary()
					&& !forceIdField)
				continue;

			if (entry.getKey() != null)
				args[i] = entry.getKey().get(obj);
			else
				args[i] = analyzed.getTargetClass().getName();

			i++;
		}
		return args;
	}

	/**
	 * Generate the SQL statement that allows for insertion into the DB for a given class.
	 * 
	 * @param analyzed
	 * @return
	 */
	public String saveStatement(@NonNull AnalyzedClass<?> analyzed) {
		return saveStatement(analyzed, false);
	}

	/**
	 * Generate the SQL statement that allows for insertion into the DB for a given class.
	 * 
	 * @param <T>
	 * @param analyzed
	 * @param forceIdField
	 *            if the analyzed class uses auto generation for it's key, normally that column is not included in the
	 *            insert statement.
	 *            If this is set to true, it will be included even if auto generation is true.
	 * @return
	 */
	public String saveStatement(@NonNull AnalyzedClass<?> analyzed, boolean forceIdField) {
		StringBuilder builder = new StringBuilder("INSERT INTO ");

		builder.append(analyzed.getTable() + " (");
		for (Iterator<ColumnDefinition<?>> i = analyzed.getFields().values().iterator(); i.hasNext();) {
			ColumnDefinition<?> col = i.next();

			if (analyzed.useAutoGeneration() && col.isPrimary() && !forceIdField)
				continue;

			builder.append(col.getName());
			if (i.hasNext())
				builder.append(", ");
		}
		builder.append(") VALUES (");

		// Add one less ? if the id won't be inserted
		int startAt = analyzed.useAutoGeneration() && !forceIdField ? 1 : 0;
		for (int i = startAt; i < analyzed.getFields().size(); i++) {
			builder.append("?");
			if (i + 1 < analyzed.getFields().size())
				builder.append(", ");
		}

		builder.append(")");
		return builder.toString();
	}

	public String onDuplicateKeyUpdateStatement(@NonNull AnalyzedClass<?> analyzed) {
		var builder = new StringBuilder(" ON DUPLICATE KEY UPDATE ");

		for (Iterator<ColumnDefinition<?>> i = analyzed.getFields().values().iterator(); i.hasNext();) {
			ColumnDefinition<?> col = i.next();
			if (col.isPrimary())
				continue;

			builder.append(col.getName() + " = ?");
			if (i.hasNext())
				builder.append(", ");
		}
		return builder.toString();
	}

	public <T> Object[] makeOnDuplicateArguments(@NonNull AnalyzedClass<T> analyzed, T obj) throws IllegalArgumentException, IllegalAccessException {
		Object[] args = new Object[analyzed.getFields().size() - 1];
		
		int i = 0;
		for (Entry<Field, ColumnDefinition<?>> entry : analyzed.getFields().entrySet()) {
			if (analyzed.useAutoGeneration()
					&& entry.getValue().isPrimary())
				continue;

			if (entry.getKey() != null)
				args[i] = entry.getKey().get(obj);
			else
				args[i] = analyzed.getTargetClass().getName();

			i++;
		}
		return args;
	}
}
